<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gothic Chronicle (Prototype)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; background: #060606; color: #e7e7e7;
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      line-height: 1.35;
    }
    .wrap { max-width: 920px; margin: 0 auto; padding: 18px; }
    header { display:flex; gap:12px; align-items:baseline; flex-wrap:wrap; }
    header h1 { margin: 0; font-size: 22px; letter-spacing: 0.5px; }
    header .sub { color:#b8b8b8; font-size: 13px; }
    .panel {
      margin-top: 14px;
      background: #0d0d0d; border: 1px solid #1e1e1e;
      border-radius: 14px; padding: 14px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }
    .scene { font-size: 18px; }
    .meta { color:#bdbdbd; font-size: 13px; margin-top: 10px; }
    .choices { margin-top: 12px; display: grid; gap: 10px; }
    button.choice {
      text-align:left;
      background:#0b0b0b; color:#f0f0f0;
      border:1px solid #2a2a2a;
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      transition: transform 0.05s ease, border-color 0.1s ease;
    }
    button.choice:hover { border-color:#444; }
    button.choice:active { transform: translateY(1px); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-top: 10px;}
    .tinybtn {
      background:#111; border:1px solid #2a2a2a; color:#ddd;
      border-radius: 10px; padding: 8px 10px; cursor:pointer;
    }
    .tinybtn:hover { border-color:#444; }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; color:#cfcfcf;
      border:1px solid #2a2a2a; border-bottom-color:#444;
      padding: 1px 6px; border-radius: 8px; background:#0a0a0a;
    }
    details { margin-top: 12px; }
    pre {
      white-space: pre-wrap; word-break: break-word;
      background:#070707; border:1px solid #1e1e1e;
      border-radius: 12px; padding: 12px; color:#d6d6d6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Gothic Chronicle</h1>
      <div class="sub">Choice-based, non-linear prototype — deterministic world, flavorful narration.</div>
    </header>

    <div class="panel">
      <div id="scene" class="scene"></div>
      <div id="meta" class="meta"></div>

      <div class="choices" id="choices"></div>

      <div class="row">
        <button class="tinybtn" id="btnInv">Inventory</button>
        <button class="tinybtn" id="btnChron">Chronicle</button>
        <button class="tinybtn" id="btnSave">Force Save</button>
        <button class="tinybtn" id="btnReset">Hard Reset</button>
        <span class="sub">Quick keys: <span class="kbd">1-9</span> choose • <span class="kbd">I</span> inventory • <span class="kbd">C</span> chronicle</span>
      </div>

      <details id="drawer" style="display:none;">
        <summary id="drawerTitle">Drawer</summary>
        <pre id="drawerBody"></pre>
      </details>
    </div>

    <div class="panel">
      <div class="sub">
        Hook point for later: when the engine emits an image trigger, it appears in the Chronicle as a block you can have AHK detect and route to an image generator.
      </div>
    </div>
  </div>

  <script src="game.js"></script>
</body>
</html>
2) game.js
/* Gothic Chronicle — deterministic engine + dynamic choice text.
   Save: localStorage key "gothicChronicle.save.v1"
*/

const SAVE_KEY = "gothicChronicle.save.v1";

/* ---------------------------
   WORLD DATA (deterministic)
---------------------------- */
const WORLD = {
  rooms: {
    gate: {
      name: "Iron Gate",
      descSeed: "A rusted iron gate stands between you and the estate. Fog coils like breath in winter.",
      exits: { north: { to: "courtyard", requiresFlag: "gate_unlocked" }, east: { to: "wallpath" } },
      items: ["old_note"],
      tags: ["outdoors", "fog", "threshold"],
      firstVisitMilestone: "m_gate_first"
    },
    wallpath: {
      name: "Outer Wall Path",
      descSeed: "You follow stonework slick with damp. The wall rises like a mute witness.",
      exits: { west: { to: "gate" }, north: { to: "servicedoor" } },
      items: [],
      tags: ["outdoors", "stone", "quiet"]
    },
    servicedoor: {
      name: "Service Door",
      descSeed: "A narrow door with a stubborn lock. Scratches mark the wood as if something begged to be let in—or out.",
      exits: { south: { to: "wallpath" }, north: { to: "kitchen" , requiresFlag: "service_unlocked"} },
      items: [],
      tags: ["wood", "lock"],
      lock: { flagToSet: "service_unlocked", keyItem: "brass_key" }
    },
    courtyard: {
      name: "Courtyard",
      descSeed: "Moonlight spills into a courtyard of broken statues. A fountain lies cracked, the water black and still.",
      exits: { south: { to: "gate" }, north: { to: "foyer" } },
      items: ["brass_key"],
      tags: ["outdoors", "moonlight", "statues"],
      firstVisitMilestone: "m_courtyard_first"
    },
    kitchen: {
      name: "Kitchen",
      descSeed: "Cold hearth. Hanging hooks. The smell of iron and old herbs. Someone has been here recently—barely.",
      exits: { south: { to: "servicedoor" } },
      items: ["matchbook"],
      tags: ["indoors", "hearth", "stale"]
    },
    foyer: {
      name: "Foyer",
      descSeed: "A grand foyer stripped of warmth. Portraits stare with eyes too certain. The staircase ascends into shadow.",
      exits: { south: { to: "courtyard" }, east: { to: "library", requiresFlag: "candle_lit" } },
      items: ["candle"],
      tags: ["indoors", "portraits", "echo"],
      firstVisitMilestone: "m_foyer_first"
    },
    library: {
      name: "Library",
      descSeed: "Books like tombstones. Dust thick as velvet. In the corner, a lectern waits like an accusation.",
      exits: { west: { to: "foyer" } },
      items: ["silver_seal"],
      tags: ["indoors", "books", "secrets"],
      firstVisitMilestone: "m_library_first"
    }
  },

  items: {
    old_note: {
      name: "Old Note",
      synonyms: ["note", "paper"],
      examine: "The ink has bled, but one line remains: “Do not enter unlit. The house favors the unseen.”"
    },
    brass_key: {
      name: "Brass Key",
      synonyms: ["key"],
      examine: "A brass key, warm despite the air. The teeth are worn as if often turned in fear."
    },
    matchbook: {
      name: "Matchbook",
      synonyms: ["matches", "match"],
      examine: "A cheap matchbook. The cover bears a faded crest—three ravens and a crown."
    },
    candle: {
      name: "Candle",
      synonyms: ["wax", "candle"],
      examine: "A pale candle. Unlit. The wick looks strangely new."
    },
    silver_seal: {
      name: "Silver Seal",
      synonyms: ["seal", "sigil"],
      examine: "A cold silver seal engraved with a crescent and thorned rose. It feels like a boundary."
    }
  }
};

/* ---------------------------
   STATE (local + deterministic)
---------------------------- */
function defaultState() {
  return {
    roomId: "gate",
    inventory: [],
    flags: {},            // boolean flags
    visited: {},          // roomId -> count
    milestones: {},       // milestoneId -> true
    turn: 0,
    chronicle: []         // list of entries (strings)
  };
}

let STATE = loadState();

/* ---------------------------
   SAVE / LOAD
---------------------------- */
function loadState() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return defaultState();
    const parsed = JSON.parse(raw);
    // minimal migration / validation
    if (!parsed || !parsed.roomId) return defaultState();
    return { ...defaultState(), ...parsed };
  } catch {
    return defaultState();
  }
}

function saveState() {
  localStorage.setItem(SAVE_KEY, JSON.stringify(STATE));
}

/* ---------------------------
   HELPERS
---------------------------- */
function room() {
  return WORLD.rooms[STATE.roomId];
}
function hasItem(itemId) {
  return STATE.inventory.includes(itemId);
}
function setFlag(flag, val = true) {
  STATE.flags[flag] = !!val;
}
function hasFlag(flag) {
  return !!STATE.flags[flag];
}
function addChron(entry) {
  STATE.chronicle.push(entry);
  // keep it from growing forever
  if (STATE.chronicle.length > 300) STATE.chronicle.shift();
}

/* ---------------------------
   INTENTS (legal move set)
   Engine generates these deterministically.
---------------------------- */
function getLegalIntents() {
  const r = room();
  const intents = [];

  // Move intents (by exits + conditions)
  for (const [dir, ex] of Object.entries(r.exits || {})) {
    if (ex.requiresFlag && !hasFlag(ex.requiresFlag)) continue;
    intents.push({ id: `MOVE_${dir.toUpperCase()}`, type: "move", dir, to: ex.to });
  }

  // Examine room + things
  const visibleItemIds = (r.items || []);
  const examineTargets = [
    { kind: "room", id: STATE.roomId, label: r.name },
    ...visibleItemIds.map(it => ({ kind: "item", id: it, label: WORLD.items[it]?.name || it })),
    ...STATE.inventory.map(it => ({ kind: "inv", id: it, label: WORLD.items[it]?.name || it }))
  ];
  intents.push({ id: "EXAMINE", type: "examine", targets: examineTargets });

  // Take item intents (visible items)
  for (const it of visibleItemIds) {
    intents.push({ id: `TAKE_${it}`, type: "take", itemId: it });
  }

  // Use item (simple demo rules: light candle with matchbook)
  if (hasItem("matchbook") && (visibleItemIds.includes("candle") || hasItem("candle")) && !hasFlag("candle_lit")) {
    intents.push({ id: "LIGHT_CANDLE", type: "use", action: "light_candle" });
  }

  // Unlock service door if in servicedoor room and have brass key and not unlocked
  if (STATE.roomId === "servicedoor") {
    const lock = r.lock;
    if (lock && !hasFlag(lock.flagToSet)) {
      if (hasItem(lock.keyItem)) intents.push({ id: "UNLOCK_SERVICE", type: "unlock", flag: lock.flagToSet });
      else intents.push({ id: "RATTLE_LOCK", type: "misc", action: "rattle_lock" });
    }
  }

  // Inventory & wait always available
  intents.push({ id: "INVENTORY", type: "inventory" });
  intents.push({ id: "WAIT", type: "wait" });

  return intents;
}

/* ---------------------------
   GPT-LIKE CHOICE TEXT
   (For now: local template “narrator”.
   Later you can replace these strings with real GPT output
   as long as they map to the same intent IDs.)
---------------------------- */
function narrateScene() {
  const r = room();
  const visitedCount = STATE.visited[STATE.roomId] || 0;

  // deterministic base + slight variation by state
  let text = r.descSeed;

  if (STATE.roomId === "foyer" && !hasFlag("candle_lit")) {
    text += " The darker corners seem to hold their breath, waiting for you to notice them.";
  }
  if (STATE.roomId === "foyer" && hasFlag("candle_lit")) {
    text += " The candlelight makes the portraits look less alive—and somehow more judgmental.";
  }
  if (visitedCount > 1) {
    text += " The place feels familiar now, which is its own kind of wrong.";
  }

  return text;
}

function prettyChoice(intent) {
  const r = room();

  // Movement
  if (intent.type === "move") {
    const toName = WORLD.rooms[intent.to]?.name || intent.to;
    const dir = intent.dir.toLowerCase();
    const styles = {
      north: `Go north, toward ${toName}.`,
      south: `Retreat south, back toward ${toName}.`,
      east:  `Slip east toward ${toName}.`,
      west:  `Head west toward ${toName}.`
    };
    // add a little gothic spice
    if (r.tags?.includes("fog") && dir === "north") return `Push through the fog and go north to ${toName}.`;
    return styles[dir] || `Go ${dir} to ${toName}.`;
  }

  // Take
  if (intent.type === "take") {
    const nm = WORLD.items[intent.itemId]?.name || intent.itemId;
    return `Take the ${nm.toLowerCase()}.`;
  }

  // Examine
  if (intent.type === "examine") {
    // Make a short submenu-like option
    return `Examine something more closely.`;
  }

  // Use / special
  if (intent.id === "LIGHT_CANDLE") return `Strike a match and light the candle.`;
  if (intent.id === "UNLOCK_SERVICE") return `Use the brass key to unlock the service door.`;
  if (intent.id === "RATTLE_LOCK") return `Test the lock with a careful hand.`;

  // Inventory / wait
  if (intent.type === "inventory") return `Check your inventory.`;
  if (intent.type === "wait") return `Wait… and listen.`;

  return `Do something. (${intent.id})`;
}

/* ---------------------------
   APPLY INTENT (mechanics)
---------------------------- */
function applyIntent(intent) {
  const r = room();
  STATE.turn += 1;

  // Mark visit
  STATE.visited[STATE.roomId] = (STATE.visited[STATE.roomId] || 0) + 1;

  // Milestones on first visit (image hook)
  if (r.firstVisitMilestone && !STATE.milestones[r.firstVisitMilestone]) {
    STATE.milestones[r.firstVisitMilestone] = true;
    emitImageTrigger(r.name, r.descSeed);
  }

  // Actions
  if (intent.type === "move") {
    STATE.roomId = intent.to;
    addChron(`Turn ${STATE.turn}: Moved ${intent.dir.toUpperCase()} to ${WORLD.rooms[intent.to]?.name || intent.to}.`);
    return;
  }

  if (intent.type === "take") {
    const itemId = intent.itemId;
    if ((r.items || []).includes(itemId)) {
      // remove from room
      r.items = r.items.filter(x => x !== itemId);
      STATE.inventory.push(itemId);
      addChron(`Turn ${STATE.turn}: Took ${WORLD.items[itemId]?.name || itemId}.`);
    } else {
      addChron(`Turn ${STATE.turn}: Tried to take ${itemId}, but it wasn't there.`);
    }
    return;
  }

  if (intent.type === "unlock") {
    setFlag(intent.flag, true);
    addChron(`Turn ${STATE.turn}: Unlocked something (${intent.flag}).`);
    return;
  }

  if (intent.type === "use" && intent.action === "light_candle") {
    setFlag("candle_lit", true);
    addChron(`Turn ${STATE.turn}: Lit the candle.`);
    emitImageTrigger("Candlelight", "A candle flares to life, casting harsh, honest shadows.");
    return;
  }

  if (intent.type === "misc" && intent.action === "rattle_lock") {
    addChron(`Turn ${STATE.turn}: The lock refuses you. It sounds… pleased.`);
    return;
  }

  if (intent.type === "inventory") {
    showDrawer("Inventory", inventoryText());
    addChron(`Turn ${STATE.turn}: Checked inventory.`);
    return;
  }

  if (intent.type === "wait") {
    addChron(`Turn ${STATE.turn}: Waited. The estate waited back.`);
    return;
  }

  if (intent.type === "examine") {
    showDrawer("Examine", examineText(intent.targets));
    addChron(`Turn ${STATE.turn}: Examined surroundings.`);
    return;
  }

  addChron(`Turn ${STATE.turn}: Did ${intent.id}.`);
}

/* ---------------------------
   UI — drawer helpers
---------------------------- */
function showDrawer(title, body) {
  const drawer = document.getElementById("drawer");
  const drawerTitle = document.getElementById("drawerTitle");
  const drawerBody = document.getElementById("drawerBody");
  drawer.style.display = "block";
  drawer.open = true;
  drawerTitle.textContent = title;
  drawerBody.textContent = body;
}

function hideDrawer() {
  const drawer = document.getElementById("drawer");
  drawer.open = false;
}

function inventoryText() {
  if (STATE.inventory.length === 0) return "You carry nothing but your nerve.";
  return STATE.inventory
    .map(id => `- ${WORLD.items[id]?.name || id}`)
    .join("\n");
}

function examineText(targets) {
  // simple: list things you can examine; player can just re-open and read item descriptions
  // (later: make examine a second-stage choice menu)
  let out = "You consider:\n";
  for (const t of targets) out += `- ${t.label}\n`;
  out += "\nItem notes you can read:\n";
  for (const id of STATE.inventory) {
    const it = WORLD.items[id];
    if (it?.examine) out += `\n${it.name}:\n${it.examine}\n`;
  }
  // visible room items too
  for (const id of (room().items || [])) {
    const it = WORLD.items[id];
    if (it?.examine) out += `\n${it.name}:\n${it.examine}\n`;
  }
  return out.trim();
}

/* ---------------------------
   IMAGE TRIGGER (AHK hook later)
---------------------------- */
function emitImageTrigger(subject, beat) {
  const block =
`===IMAGE_TRIGGER===
subject: ${subject}
style: Victorian gothic engraving, ink etching, chiaroscuro, 19th-century illustration, dark fantasy
beat: ${beat}
constraints: no modern objects, no neon, no text, moody shadows, subtle fog
===END===`;
  addChron(block);
}

/* ---------------------------
   RENDER
---------------------------- */
function render() {
  const sceneEl = document.getElementById("scene");
  const metaEl = document.getElementById("meta");
  const choicesEl = document.getElementById("choices");

  const r = room();
  const intents = getLegalIntents();

  sceneEl.textContent = narrateScene();

  const visible = (r.items || []).map(id => WORLD.items[id]?.name || id);
  metaEl.textContent =
    `${r.name} • Turn ${STATE.turn} • ` +
    (visible.length ? `You notice: ${visible.join(", ")}.` : `Nothing obvious presents itself.`);

  choicesEl.innerHTML = "";

  // Build visible choice list
  const choiceList = intents.map((intent, idx) => ({
    idx,
    intent,
    label: prettyChoice(intent)
  }));

  // Render
  for (let i = 0; i < choiceList.length && i < 9; i++) {
    const { intent, label } = choiceList[i];
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.textContent = `${i + 1}) ${label}`;
    btn.onclick = () => chooseByIndex(i);
    choicesEl.appendChild(btn);
  }

  // auto-save
  saveState();
  hideDrawer();
}

function chooseByIndex(i) {
  const intents = getLegalIntents();
  const intent = intents[i];
  if (!intent) return;
  applyIntent(intent);
  render();
}

/* ---------------------------
   INPUT — number keys + I/C
---------------------------- */
window.addEventListener("keydown", (e) => {
  if (e.repeat) return;

  // 1-9
  if (e.key >= "1" && e.key <= "9") {
    const i = parseInt(e.key, 10) - 1;
    chooseByIndex(i);
  }

  // I inventory
  if (e.key.toLowerCase() === "i") {
    showDrawer("Inventory", inventoryText());
  }

  // C chronicle
  if (e.key.toLowerCase() === "c") {
    showDrawer("Chronicle", STATE.chronicle.slice(-80).join("\n\n"));
  }

  // Escape closes drawer
  if (e.key === "Escape") {
    hideDrawer();
  }
});

/* ---------------------------
   BUTTONS
---------------------------- */
document.getElementById("btnInv").onclick = () => showDrawer("Inventory", inventoryText());
document.getElementById("btnChron").onclick = () => showDrawer("Chronicle", STATE.chronicle.slice(-80).join("\n\n"));
document.getElementById("btnSave").onclick = () => { saveState(); showDrawer("Saved", "State saved to localStorage."); };
document.getElementById("btnReset").onclick = () => {
  localStorage.removeItem(SAVE_KEY);
  STATE = defaultState();
  showDrawer("Reset", "Hard reset done. Reloading scene…");
  render();
};

/* ---------------------------
   BOOT
---------------------------- */
render();
